% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bsvar.R
\name{bsvar}
\alias{bsvar}
\title{Bayesian Estimation of non-Gaussian SVARs}
\usage{
bsvar <- function(
y,
lags,
include_constant = TRUE,
dist = "st",
dist_control = list("fix_moments" = 2),
B_inverse = TRUE,
B_pos_diag = TRUE,
B_restrictions = NULL,
A_restrictions = NULL,
include_minnesota = TRUE,
minnesota_control = list("minnesota_means" = 1,
                         "hyper_free" = c(1, 0, 0),
                         "hyper_fixed_values" = c(0.2, 1, 0.5),
                         "hyper_shrinkage_prior" = c(0, 1, 0.001),
                         "soc" = FALSE, "dio" = FALSE),
include_garch = FALSE,
garch_control = list("garch_prior" = 10/12,
                     "garch_dep" = FALSE,
                     "garch_shrinkage" = 1,
                     "garch_groups" = NULL,
                     "garch_eta_form" = FALSE),
vol_breaks = NULL,
other_priors = list("B_prior" = c(2^2, NA),
                    "prior_elasticity" = NULL,
                    "constant_prior" = c(0, Inf),
                    "lambda_prior" = c(4, 4),
                    "p_prior" = c(1, 1),
                    "q_prior" = c(2, 1),
                    "p_q_prior_shift" = NULL,
                    "hyper_B_prior" = c(0, 1),
                    "hyper_B_soft_prior" = c(4, 4),
                    "vol_breaks_prior" = 2),
chains = 4,
parallel_chains = ifelse(chains <= 4, chains, 4),
threads_per_chain = 1,
max_treedepth = 15,
control = list(),
...
)
}
\arguments{
\item{y}{Typically a data matrix or a time series object of dimension
\mjseqn{N \times M}.
Columns include the time series, whereas rows refer to observations.
NA values are allowed everywhere except for the first row in the data.
Can also be a positive integer (no data), which refers to a prior model
with M given by the provided integer.}

\item{lags}{Non-negative integer. The number of autoregressive lags, \mjseqn{p}.}

\item{include_constant}{Logical. Should an intercept term be included in the model?}

\item{dist}{Character string. The distribution of shocks. Allowed values are: \cr
\mjseqn{\phantom{..}} "sgt" (skewed generalized \emph{t}-distribution), \cr
\mjseqn{\phantom{..}} "st" (skewed \emph{t}-distribution; recommended), \cr
\mjseqn{\phantom{..}} "t" (\emph{t}-distribution), \cr
\mjseqn{\phantom{..}} "snormal" (skewed normal distribution), \cr
\mjseqn{\phantom{..}} "normal" (normal distribution; not recommended), \cr
\mjseqn{\phantom{..}} "custom" (see Details)}

\item{dist_control}{Named list. Further arguments for specification of shock
distributions go here. Most importantly, `fix_moments` accepts values: \cr
\mjseqn{\phantom{..}} 0 (zero mode and unit scale assumed, mean and variance not fixed), \cr
\mjseqn{\phantom{..}} 1 (zero mean and unit scale assumed, variance not fixed), \cr
\mjseqn{\phantom{..}} 2 (zero mean and unit variance assumed; recommended). \cr
See Details for more.}

\item{B_inverse}{Logical. By default `TRUE`. \cr
\mjseqn{\phantom{..}} If `TRUE`, the error term is defined as \mjseqn{u_t = B^{-1} \varepsilon_t}. \cr
\mjseqn{\phantom{..}} If `FALSE`, the error term is defined as \mjseqn{u_t = B \varepsilon_t}. \cr
The former is computationally more efficient, while the latter allows for restrictions/priors
directly on the effects of the shocks \mjseqn{\varepsilon_t}.}

\item{B_pos_diag}{Logical. Should a positive sign restriction on the diagonal
of \mjseqn{B} be imposed? Defaults to `TRUE` as this is computationally convenient
and comes with a very little cost in generality.}

\item{B_restrictions}{Either NULL or a matrix of dimension \mjseqn{M \times M}.
The matrix can be used to impose restrictions on the elements of \mjseqn{B}.
Overrides `B_pos_diag` if not NULL.
Note that the value of `B_inverse` affects the interpretation of these restrictions.
Allowed values for the restriction matrix are: \cr
\mjseqn{\phantom{..}} NA (no restriction), \cr
\mjseqn{\phantom{..}} 0 (zero restriction), \cr
\mjseqn{\phantom{..}} 1 (positive sign restriction), \cr
\mjseqn{\phantom{..}} -1 (negative sign restriction). \cr}

\item{A_restrictions}{Either NULL or a matrix of dimension \mjseqn{Mp \times M}.
The matrix can be used to impose restrictions on the elements of the matrix of
autoregressive parameters \mjseqn{A}. Only zero restrictions are allowed, that is,
the matrix takes only values NA (no restriction) or 0 (zero restriction).}

\item{include_minnesota}{Logical. Should a Minnesota prior on the autoregressive
parameters be imposed? Defaults to `TRUE` (highly recommended).}

\item{minnesota_control}{Named list. Further arguments for specification of the
Minnesota prior go here. Most importantly, by default the overall strength of the
prior is estimated from the data in a hierarchical fashion. Also, the prior mean
on the first order autoregressive coefficients is by default 1 for each equation.
This can be controlled via `minnesota_means`, which allows either a scalar or a
vector of length \mjseqn{M}. See Details for more.}

\item{include_garch}{Logical. Should the shock volatility be modeled via GARCH-process?
Defaults to `FALSE` (constant shock volatility), which is computationally less burdensome.}

\item{garch_control}{Named list. Further arguments for specification of the
volatility process. Most importantly, interdependent volatility processes can be
imposed by setting `garch_dep = TRUE`, which may however be computationally burdensome.
By default the volatility processes are mutually independent. See Details for more.}

\item{vol_breaks}{Either NULL or a list. Must be NULL if `include_garch = TRUE`.
Also, if not NULL, then `y` must be a time series object. A list can be provided
to specify fixed shock volatility regimes. The elements of the list should be vectors
of length two specifying the dates for the first periods of the regimes, e.g. c(1979, 10),
for all regimes but the first. See Details for more.}

\item{other_priors}{Named list. Any other priors are specified here. Default values
work well in almost any case and are highly recommended. Most importantly, the prior
on \mjseqn{B} is specified via `B_prior` most conveniently by providing a vector of
length two including the prior variance separately for the diagonal elements and
for the off-diagonal elements of \mjseqn{B}. The latter can be left NA (default),
in which case the prior variance is estimated from the data in a hierarchical fashion.
By default the prior is centered at a diagonal matrix. A list can be provided as well
for more control. See Details for more.}

\item{chains}{Positive integer. The number of Markov chains to run. The default is 4.}

\item{parallel_chains}{Positive integer. The maximum number of Markov chains to run in
parallel. Ideally equals the value of `chains`, which is the default behaviour if `chains <= 4`.}

\item{threads_per_chain}{Positive integer. Defaults to 1. Another level of parallelization.
Might give a modest performance boost up to `threads_per_chain = M` if there are enough
CPU cores available. Note that the number of CPU cores employed is `parallel_chains * threads_per_chain`.}

\item{max_treedepth}{Positive integer. The maximum allowed tree depth for the Stan's NUTS engine.
Defaults to a rather conservative value of 15, which is recommended and should be enough even for the
largest and gnarliest SVARs. Smaller values may allow for faster sampling with the risk of autocorrelated draws.
See the Tree Depth section of the CmdStan User's Guide for more details.}

\item{control}{A list of control parameters. See Details.}

\item{...}{Further arguments to be passed to \code{\link[cmdstanr]{sample}}.}
}
\value{
An object of S4 class `stanfit` representing the fitted results with `bsvar` specific
additional attributes.
}
\description{
\loadmathjax{}
Provides an easy-to-use interface to `cmdstanr` for Bayesian estimation
of non-Gaussian structural vector autoregressions (SVARs). Default
arguments are designed to work well in most cases. If unsure about the
arguments, you may just provide the data and the number of autoregressive lags.
See Details for more.
}
\details{
To be written.
}
\examples{
\dontrun{
y <- matrix(rnorm(200), ncol = 2)
fit <- bsvar(y, lags = 2)
}
}
